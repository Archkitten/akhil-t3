<html>
    <main>
        <head>
            <title>Sorts and Analysis</title>
            <link rel="stylesheet" href="main.css">
            <link rel="stylesheet" href="./fragments/main.css">
            <div id="navParent"></div>
            <script src="import.js"></script>
            <script>
                importNav();
            </script>
        </head>
        <div>
            <div id="toc" class="box rounded-corners" style="float:left;width:15%;position:fixed;left:-13%;transition:0.2s ease-in-out;" onmouseenter="toggleTOC()" onmouseleave="toggleTOC()">
                <h3>Table of Contents</h3>
                <p>
                    <ul class="blue" style="font-size:1vw;">
                        <li ><a class="blue blue-hover" href="#intro">Intro</a><br></li>
                        <li ><a class="blue blue-hover" href="#limitations">Limitations</a></li>
                        <li ><a class="blue blue-hover" href="#explanation">Explanation of Code</a></li>
                        <ul class="blue">
                            <li><a class="blue blue-hover" href="#selection">Selection Sort</a></li>
                            <li><a class="blue blue-hover" href="#merge">Merge Sort</a></li>
                            <li><a class="blue blue-hover" href="#bubble">Bubble Sort</a></li>
                        </ul>
                        <li ><a class="blue blue-hover" href="#analysis">Analysis</a></li>
                    </ul>
                </p>
            </div>
            <script>
                let toc = document.getElementById("toc");
                function toggleTOC() {
                    toc.classList.toggle("toc-shown");
                }
            </script>
            <style>
                .toc-shown {
                    left: 1% !important;
                }
            </style>
            <section class="post">
                <h1 class="post-title">Sorts and Analysis</h1>
                <p class="caption">
                    Akhil Guntur - April 3, 2022
                </p>
                <h1 id="intro">Intro</h1>
                <p class="box rounded-corners post-box">
                    Over the past week or so, I worked on implementing sorting algorithms on a data type of my own creation. 
                    In my case, this meant creating algorithms for <color class="red red-hover">selection</color>, 
                    <color class="red red-hover">bubble</color>, and <color class="red red-hover">merge</color> sorting algorithms, 
                    which I would run on a <color class="red red-hover">queue</color>, the class for which I made by myself. 
                    My hope is that my implementation will fulfull <color class="yellow yellow-hover">Objective #2</color>.
                </p>
                <h1 id="limitations">Limitations</h1>
                <p class="box rounded-corners post-box">
                    As I attempted to pursue Objective #2, there were some requirements which I wish to waive.<br>
                    My implementation of bubble sort was fairly complex (as I explain <a class="blue blue-hover" href="#bubble">later on</a>), 
                    and as a result, the performance of my algorithm was negatively affected. This made it hard for Java to process 
                    5000 elements of data for bubble sort. I tried doing so, and I have depicted my results below.
                </p>
                <div class="code-container">
                    <code>
                        Selection Sort:<br>
                        Sorted in 180555506<br>
                        <br>
                        ^C<color class="code-highlight">%</color><br>
                        <br>
                        <color class="cyan">akhil-t3</color> on <color class="purple"> main</color> 
                        <color class="red">[⇡$!+]</color> took <color class="yellow">24m 30s</color>
                    </code>
                </div>
                <p class="caption">
                    The program was set to run selection, then bubble, then merge sort.<br>
                    As shown, selection sort finished in ~0.18 sec.<br>
                    After over 24 minutes, bubble sort still wasn't done.
                </p>
                <p class="box rounded-corners post-box">
                    This is all to say that <color class="red red-hover">5000 terms was not doable</color> with my implementation, 
                    especially given how I planned on running each algorithm twelve times. 
                    And thus, I opted for a more humble <color class="red red-hover">500 terms</color>, which I found can still reveal how 
                    not all sorting algorithms are made equal.<br>
                    Other than that, I believe I incorporated all required elements of the assignment.
                </p>
                <h1 id="explanation">Explanation of Code</h1>
                <p class="box rounded-corners post-box">
                    Each sorting algorithm is a subclass of the Sort superclass. From this superclass, each algorithm inherit a 
                    Queue in which times can be stored, a method to add times to the <color class="red red-hover">Queue</color>, a 
                    <color class="red red-hover">method</color> to average all times (removing the lowest and highest times), and a 
                    <color class="red red-hover">method</color> to make sure the sorted Queue really is sorted. Along with those, the 
                    Sort class contains the <code class="yellow">generateData()</code> method, which fills the 
                    <color color="red">static</color> data Queue with <a class="blue blue-hover" href="limitations">500</a> random ints. 
                    I made the data variable static to ensure that it was constant across all of the subclass sorting algorithms.
                </p>

                <h3 id="selection">Selection Sort</h3>
                <p class="box rounded-corners post-box">
                    Selection sort involves searching through a given data set, finding the term of least value 
                    (i.e. <color class="red red-hover">selecting</color> the smallest term), adding that value to a new data set, 
                    removing it from the original set, and repeating.
                </p>
                <div class="code-container">
                    <code>
                        int lowest = Integer.<color class="blue">MAX_VALUE</color>;<br>
                        <color class="red">for</color> (int i : data) {<br>&emsp; &emsp; 
                            <color class="red">if</color> (i < lowest) {<br>&emsp; &emsp; &emsp; &emsp; 
                                lowest = i;<br>&emsp; &emsp; 
                            }<br>
                        }<br>
                    </code>
                </div>
                <p class="caption">
                    This chunk of code searches through <code class="blue">data</code>, a Queue of Integers, and finds the lowest term.<br>
                </p>
                <p class="box rounded-corners post-box">
                    As one may expect, this algorithm does not scale very well. Until the set is fully sorted, the algorithm searches term-by-term 
                    through the entire set to find the lowest int.<br>
                    Since Selection Sort involves searching through the data set of length <color class="yellow yellow-hover">n</color> 
                    a total of <color class="yellow yellow-hover">n</color> times, this algorithm has a time complexity of 
                    <color class="yellow yellow-hover">O(n<sup>2</sup>)</color>.
                </p>
                <h3 id="merge">Merge Sort</h3>
                <p class="box rounded-corners post-box">
                    By contrast, the merge sort is a relatively efficient sorting algorithm. It involves splitting a given data set in halves 
                    until single-element sets are formed. Single-element sets of a common parent are compared with each other and sorted. 
                    These sets are then <color class="red red-hover">merged</color> back together to form a complete, sorted set.
                </p>
            </section>
            <div style="display:flex;width:75%;margin:auto;">
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
                            int sta = 0;<br>
                            int mid = data.<color class="purple">size</color>()/<color class="blue">2</color>;<br>
                            int end = data.<color class="purple">size</color>();<br>
                            <br>
                            int halfOne = mid - sta;<br>
                            int halfTwo = end - mid;<br>
                        </code>
                    </div>
                    <p class="caption">
                        Variables are initialized. These will be used to split the data set into multiple sets.
                    </p>
                </div>
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
                            Queue&lt;Integer&gt; qOne = <color class="red">new</color> Queue<>();<br>
                            Queue&lt;Integer&gt; qTwo = <color class="red">new</color> Queue<>();<br>
                            <br>
                            <color class="red"r>for</color> (int i=<color class="blue">0</color>; i&lt;halfTwo; i++) {<br>&emsp; &emsp; 
                                qTwo.<color class="purple">enqueue</color>(data.<color class="purple">peek</color>());<br>&emsp; &emsp; 
                                if (data.<color class="purple">size</color>()><color class="blue">0</color>) {<br>&emsp; &emsp; &emsp; &emsp; 
                                    data.<color class="purple">dequeue</color>();<br>&emsp; &emsp; 
                                }<br>
                            }<br>
                            <color class="red"r>for</color> (int i=<color class="blue">0</color>; i&lt;halfOne; i++) {<br>&emsp; &emsp; 
                                qTwo.<color class="purple">enqueue</color>(data.<color class="purple">peek</color>());<br>&emsp; &emsp; 
                                if (data.<color class="purple">size</color>()><color class="blue">0</color>) {<br>&emsp; &emsp; &emsp; &emsp; 
                                    data.<color class="purple">dequeue</color>();<br>&emsp; &emsp; 
                                }<br>
                            }<br>
                        </code>
                    </div>
                    <p class="caption" style="width:90%;">
                        Queues are initialized. The original data set is split into two sets.
                    </p>
                </div>
                <div style="margin:auto;">
                    <div class="code-container">
                        <code>
                            <color class="red">if</color> (qOne.<color class="purple">size</color>()><color class="blue">1</color>) {<br>&emsp; &emsp; 
                                qOne = <color class="purple">Sort</color>(qOne);<br>
                            }<b></b>
                            <color class="red">if</color> (qTwo.<color class="purple">size</color>()><color class="blue">1</color>) {<br>&emsp; &emsp; 
                                qTwo = <color class="purple">Sort</color>(qTwo);<br>
                            }<br>
                        </code>
                    </div>
                    <p class="caption">
                        These Queues are then split further until they only contain one element
                    </p>
                </div>
            </div>
            <section class="post">
                <p class="box rounded-corners post-box">
                    Since Merge Sort's algorithm involves halving a given data set many times, this algorithm has a time complexity of 
                    <color class="yellow yellow-hover">O(n log(n))</i></color>.
                </p>
                <h3 id="bubble">Bubble Sort</h3>
                <p class="box rounded-corners post-box">
                    Bubble Sort was by far the least efficient algorithm I tested, as illustrated by the issues I detailed 
                    <a class="blue blue-hover" href="#limitations">earlier</a>. I challenged myself to implement the algorithm only using 
                    classes I made, and I ended up having to use both <color class="yellow yellow-hover">Queues</color> and 
                    <color class="yellow yellow-hover">Stacks</color> to successfully accomplish this task.
                </p>
            </section>
            <div style="display:flex;width:75%;margin:auto;">
                <div style="margin:auto;width:25%;">
                   <div class="code-container">
                       <code>
                            Queue&lt;Integer&gt; temp = <color class="red">new</color> Queue<>();<br>
                            Stack&lt;Integer&gt; newData = <color class="red">new</color> Stack<>();<br>
                            Queue&lt;Integer&gt; newDataQ = <color class="red">new</color> Queue<>();<br>
                       </code>
                   </div>
                   <p class="caption" style="width:100%;">
                        Queues and Stacks are initialized. The data Queue will first be sorted into a Stack, and converted into a Queue at the end.
                   </p>
                </div>
                <div style="margin:auto;width:25%;">
                    <div class="code-container">
                        <code>
                            boolean found = <color class="blue">false</color>;<br>
                            int previous = <color class="blue">-1</color>;<br>
                            <color class="red">for</color> (int i : data) {<br>&emsp; &emsp; 
                                <color class="red">if</color> (!found) {<br>&emsp; &emsp; &emsp; &emsp; 
                                    newData.<color class="purple">push</color>(i);<br>&emsp; &emsp; 
                                }<br>&emsp; &emsp; 
                                <color class="red">else</color> {<br>&emsp; &emsp; &emsp; &emsp; 
                                    temp.<color class="purple">enqueue</color>(i);<br>&emsp; &emsp; 
                                }<br>&emsp; &emsp; 
                                <color class="red">if</color> (i < previous) {<br>&emsp; &emsp; &emsp; &emsp; 
                                    found = <color class="blue">true</color>;<br>&emsp; &emsp; 
                                }<br>&emsp; &emsp; 
                                previous = i;<br>
                            }<br>
                        </code>
                    </div>
                    <p class="caption" style="width:100%">
                        The data set is parsed for anomolies (where an int is smaller than the previous int). 
                        Until one is found, terms are added to a Stack. Afterwards, terms are added to a Queue.
                    </p>
                </div>
                <div style="margin:auto;width:25%;">
                    <div class="code-container">
                        <code>
                            int smaller = newData.<color class="purple">peek</color>();<br>
                            newData.<color class="purple">pop</color>();<br>
                            int bigger = newData.<color class="purple">peek</color>();<br>
                            newData.<color class="purple">pop</color>();<br>
                            newData.<color class="purple">push</color>(smaller);<br>
                            newData.<color class="purple">push</color>(bigger);<br>
                            <br>
                            <color class="red">while</color> (temp.size()>0) {<br>&emsp; &emsp; 
                                newData.<color class="purple">push</color>(temp.<color class="purple">peek</color>());<br>&emsp; &emsp; 
                                temp.dequeue();<br>
                            }<br>
                        </code>
                    </div>
                    <p class="caption" style="width:100%;">
                        Since the top element of the stack is smaller than the element that precedes it, we switch the two. Then, we add the remaining elements, which were stored in the newData Queue.
                    </p>
                </div>
            </div>
            <section class="post">
               <p class="box rounded-corners post-box">
                    Bubble Sort involves reading all terms of a given data set, and in addition to that, it is a 
                    <color class="red red-hover">recursive</color> algorithm. Thus, Bubble Sort has a time complexity of 
                    <color class="yellow yellow-hover">O(n<sup>2</sup>)</color>.
               </p> 
               <h1 id="analysis">Analysis</h1>
               <p class="box rounded-corners post-box">
                    Funny penguins
               </p>
            </section>
        </div>
    </main>
</html>
